<!DOCTYPE html>
<html>
  <head>
    <title>Drive API Quickstart</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
        }

        #c {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
  </head>

  <body>

    <canvas id="c"></canvas>

    <!-- GoogleDriveAPI Setting -->
    <script type="text/javascript">
      /* exported gapiLoaded */
      /* exported gisLoaded */

      // TODO: Set to client ID and API key from the Developer Console
      const CLIENT_ID = '357106063401-grn3hm3ekani4s9f3gt0kpkie26iddjh.apps.googleusercontent.com';
      const API_KEY = 'AIzaSyDmxHhv8CYKBerO6mbQ2OnTk1lC8oMGD1Q';

      // Discovery doc URL for APIs used by the quickstart
      const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';

      // Authorization scopes required by the API; multiple scopes can be
      // included, separated by spaces.
      const SCOPES = 'https://www.googleapis.com/auth/drive.file';

      let tokenClient;
      let gapiInited = false;
      let gisInited = false;

      /**
       * Callback after api.js is loaded.
       */
      function gapiLoaded() {
        gapi.load('client', initializeGapiClient);
      }

      /**
       * Callback after the API client is loaded. Loads the
       * discovery doc to initialize the API.
       */
      async function initializeGapiClient() {
        await gapi.client.init({
          apiKey: API_KEY,
          clientId: CLIENT_ID,
          discoveryDocs: [DISCOVERY_DOC],
          scope: SCOPES
        });

        gapiInited = true;
      }

      /**
       * Callback after Google Identity Services are loaded.
       */
      function gisLoaded() {
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: CLIENT_ID,
          scope: SCOPES,
          callback: '', // defined later
        });

        gisInited = true;
      }

      /**
       * Save CSV file to Google Drive.
       */
      function saveFileToDrive(csvData, fileName, mimeType) {
        if (!gapiInited || !gisInited) {
          console.error('Google API is not initialized.');
          return;
        }

        if (!tokenClient.isSignedIn()) {
          console.error('User is not signed in.');
          return;
        }

        gapi.client.drive.files.create({
          resource: {
            name: fileName,
            mimeType: mimeType
          },
          media: {
            mimeType: mimeType,
            body: csvData
          }
        }).then(response => {
          console.log('File created:', response);
        }).catch(error => {
          console.error('Error creating file:', error);
        });
      }

      /**
       * Generate CSV data from VR headset camera positions.
       */
      function generateCSVData(positions) {
        let csvData = 'x,y,z\n';

        for (const position of positions) {
          csvData += `${position.x},${position.y},${position.z}\n`;
        }

        return csvData;
      }

      /**
       * Generate CSV file and save it to Google Drive.
       */
      function generateAndSaveCSV() {
        if (!gapiInited || !gisInited) {
          console.error('Google API is not initialized.');
          return;
        }

        if (!tokenClient.isSignedIn()) {
          console.error('User is not signed in.');
          return;
        }

        const positions = [];

        // Get VR headset camera positions and store them
        function updateCameraPosition() {
          const position = camera.position.clone();
          positions.push(position);

          setTimeout(updateCameraPosition, 1000); // Update every 1 second
        }

        updateCameraPosition();

        // Save the CSV file after a certain time
        setTimeout(() => {
          const csvData = generateCSVData(positions);
          const fileName = 'vr_camera_positions.csv';
          const mimeType = 'text/csv';

          saveFileToDrive(csvData, fileName, mimeType);
        }, 5000); // Save the file after 5 seconds
      }

      // Load Google API and Google Identity Services
      function loadGoogleAPIs() {
        const gapiScript = document.createElement('script');
        gapiScript.src = 'https://apis.google.com/js/api.js';
        gapiScript.onload = gapiLoaded;
        document.body.appendChild(gapiScript);

        const gisScript = document.createElement('script');
        gisScript.src = 'https://accounts.google.com/gsi/client';
        gisScript.onload = gisLoaded;
        document.body.appendChild(gisScript);
      }

      // Call the function to load Google APIs
      loadGoogleAPIs();

    </script>

  </body>

  <script type="module">
    // Three.js imports
    import * as THREE from 'https://unpkg.com/three@0.148.0/build/three.module.js';
    import { VRButton } from 'https://unpkg.com/three@0.148.0/examples/jsm/webxr/VRButton.js';

    // Initialize settings
    const canvas = document.querySelector('#c');
    const renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const aspect = window.innerWidth / window.innerHeight;

    // Camera settings
    const camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
    camera.position.z = 5;

    // VR settings
    document.body.appendChild(VRButton.createButton(renderer));
    renderer.xr.enabled = true;

    // Object settings
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshNormalMaterial();
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    // Animation
    let degree = 0;
    const render = function () {
      const rotation = (degree * Math.PI) / 180;
      const targetX = 2 * Math.cos(rotation);
      const targetY = 2 * Math.sin(rotation);

      cube.rotation.y = -rotation;
      cube.position.x = targetX;
      cube.position.z = targetY;

      renderer.render(scene, camera);
      degree += 1;
    };
    renderer.setAnimationLoop(render);

    // Call the function to generate and save CSV file
    generateAndSaveCSV();
  </script>
</html>
