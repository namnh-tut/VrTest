<!DOCTYPE html>
<html>
  <head>
    <title>Drive API Quickstart</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
        }

        #c {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
  </head>

  <body>

    <canvas id="c"></canvas>
    <!-- <pre id="content" style="white-space: pre-wrap;"></pre> -->

    <!-- GoogleDriveAPI Setting -->
    <script type="text/javascript">
      /* exported gapiLoaded */
      /* exported gisLoaded */
      /* exported handleAuthClick */
      /* exported handleSignoutClick */

      // TODO(developer): Set to client ID and API key from the Developer Console
      const CLIENT_ID = '357106063401-grn3hm3ekani4s9f3gt0kpkie26iddjh.apps.googleusercontent.com';
  const API_KEY = 'AIzaSyDmxHhv8CYKBerO6mbQ2OnTk1lC8oMGD1Q';

      // Discovery doc URL for APIs used by the quickstart
      const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';

      // Authorization scopes required by the API; multiple scopes can be
      // included, separated by spaces.
      const SCOPES = 'https://www.googleapis.com/auth/drive.file';

      let tokenClient;
      let gapiInited = false;
      let gisInited = false;

      /**
       * Callback after api.js is loaded.
       */
      function gapiLoaded() {
        gapi.load('client', initializeGapiClient);
      }

      /**
       * Callback after the API client is loaded. Loads the
       * discovery doc to initialize the API.
       */
      let apiInitialized = false;
      async function initializeGapiClient() {
        await gapi.client.init({
          apiKey: API_KEY,
          discoveryDocs: [DISCOVERY_DOC],
        });
        gapiInited = true;
        handleAuthClick();
        apiInitialized = true;
      }

      /**
       * Callback after Google Identity Services are loaded.
       */
      function gisLoaded() {
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: CLIENT_ID,
          scope: SCOPES,
          callback: '', // defined later
        });
        gisInited = true;
      }

      /**
       * Sign in the user upon button click.
       */
      let signInChecker = false;
      function handleAuthClick() {
        tokenClient.callback = async (resp) => {
          if (resp.error !== undefined) {
            throw (resp);
          }
          signInChecker = true;
          setTimeout(saveCameraPositionsToDrive, 5000);
        };

        if (gapi.client.getToken() === null) {
          // Prompt the user to select a Google Account and ask for consent to share their data
          // when establishing a new session.
          tokenClient.requestAccessToken({prompt: 'consent'});
        } else {
          // Skip display of account chooser and consent dialog for an existing session.
          tokenClient.requestAccessToken({prompt: ''});
        }
      }

      // CSV-file setting
      const fileName = 'camera_positions.csv';
      const mimeType = 'text/csv';
      let csvData = 'x,y,z\n';

      // Save camera positions to Google Drive
      function saveCameraPositionsToDrive() {
        gapi.client.drive.files.create({
          resource: {
            name: fileName,
            mimeType: mimeType
          },
          media: {
            mimeType: mimeType,
            body: csvData
          }
        }).then(response => {
          console.log('File created:', response);
        }).catch(error => {
          console.error('Error creating file:', error);
        });
      }

      // Update camera positions every 1 second
      setInterval(updateCameraPositions, 1000);

      // Update camera positions
      function updateCameraPositions() {
        if (signInChecker) {
          const cameraPosition = camera.position;
          const cameraX = cameraPosition.x;
          const cameraY = cameraPosition.y;
          const cameraZ = cameraPosition.z;
          csvData += `${cameraX},${cameraY},${cameraZ}\n`;
        }
      }

    </script>
    <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>
  </body>

  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.148.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/"
      }
    }
  </script>

  <!-- Three.js -->
  <script type="module">

      // import library
      import * as THREE from 'three';
      import { VRButton } from 'three/addons/webxr/VRButton.js';

      // Initialize setting
      const canvas = document.querySelector('#c');
      var renderer = new THREE.WebGLRenderer({canvas});
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );

      var scene = new THREE.Scene();
      var aspect = window.innerWidth / window.innerHeight;

      // camera setting
      var camera = new THREE.PerspectiveCamera( 75, aspect, 0.1, 1000 );
      camera.position.z = 5;

      // VR setting
      document.body.appendChild( VRButton.createButton( renderer ) );
      renderer.xr.enabled = true;

      // Object Setting
      var geometry = new THREE.BoxGeometry( 1, 1, 1 );
      var material = new THREE.MeshNormalMaterial();
      var cube = new THREE.Mesh( geometry, material );
      scene.add( cube );

      // Animation
      let degree = 0;
      var render = function () {
        const rotation = (degree * Math.PI) / 180;
        const targetX = 2 * Math.cos(rotation);
        const targetY = 2 * Math.sin(rotation);

        cube.rotation.y = -rotation;
        cube.position.x = targetX;
        cube.position.z = targetY;

        renderer.render( scene, camera );
        degree += 1;
      };
      renderer.setAnimationLoop(render);

  </script>

</html>
